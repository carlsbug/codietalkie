//
//  ContentView.swift
//  codietalkie Watch App
//
//  Created by i539572 on 7/25/25.
//

import SwiftUI
#if canImport(WatchConnectivity)
import WatchConnectivity
#endif

// Mock Repository for Watch app compatibility
struct Repository {
    let name: String
}

// Mock LLMService for Watch app
class LLMService {
    static let shared = LLMService()
    
    func processVoiceRequest(_ request: String, repository: Repository) async throws -> CodeGenerationResponse {
        // Simulate LLM processing
        try await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
        
        // Generate Python AI project based on request
        let pythonMainFile = generatePythonMainFile(request: request)
        let pythonUtilsFile = generatePythonUtilsFile()
        let requirementsFile = generateRequirementsFile()
        let readmeFile = generatePythonReadme(request: request)
        
        // Return Python-focused response
        return CodeGenerationResponse(
            files: [
                FileChange(path: "hello_ai.py", content: pythonMainFile, operation: .create, diff: nil),
                FileChange(path: "ai_utils.py", content: pythonUtilsFile, operation: .create, diff: nil),
                FileChange(path: "requirements.txt", content: requirementsFile, operation: .create, diff: nil),
                FileChange(path: "README.md", content: readmeFile, operation: .create, diff: nil)
            ],
            commitMessage: "Generated Python AI project via CodeCraft AI",
            summary: "Created 4 Python files using advanced AI code generation",
            branchName: nil
        )
    }
    
    private func generatePythonMainFile(request: String) -> String {
        return """
#!/usr/bin/env python3
\"\"\"
Hello AI World - Advanced Python AI Application
Generated by CodeTalkie Watch App

Request: \(request)
\"\"\"

import numpy as np
import pandas as pd
from datetime import datetime
from ai_utils import AIAssistant, DataProcessor

def main():
    print("🤖 Hello, AI World!")
    print("Welcome to advanced Python AI development!")
    print(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # Initialize AI assistant
    assistant = AIAssistant()
    processor = DataProcessor()
    
    # Demonstrate AI capabilities
    print("🚀 Initializing AI systems...")
    assistant.greet()
    
    print("\\n📊 Processing sample data...")
    sample_data = processor.generate_sample_data()
    analysis_result = processor.analyze_data(sample_data)
    print(f"Data analysis complete: {analysis_result}")
    
    print("\\n🔮 Making AI predictions...")
    prediction = assistant.make_prediction(sample_data)
    print(f"AI Prediction: {prediction}")
    
    print("\\n✨ This was generated from your Apple Watch!")
    print("🎯 Ready for AI development!")

if __name__ == "__main__":
    main()
"""
    }
    
    private func generatePythonUtilsFile() -> String {
        return """
\"\"\"
AI Utilities Module
Advanced AI helper functions and classes
\"\"\"

import numpy as np
import pandas as pd
import random
from typing import List, Dict, Any

class AIAssistant:
    \"\"\"Advanced AI Assistant with multiple capabilities\"\"\"
    
    def __init__(self):
        self.name = "CodeTalkie AI"
        self.version = "1.0.0"
        self.capabilities = [
            "Data Analysis",
            "Pattern Recognition", 
            "Predictive Modeling",
            "Natural Language Processing"
        ]
    
    def greet(self):
        \"\"\"Friendly AI greeting\"\"\"
        print(f"👋 Hello! I'm {self.name} v{self.version}")
        print("🧠 My capabilities include:")
        for capability in self.capabilities:
            print(f"   • {capability}")
    
    def make_prediction(self, data: List[float]) -> str:
        \"\"\"Generate AI prediction based on data\"\"\"
        if not data:
            return "No data provided for prediction"
        
        avg = np.mean(data)
        trend = "increasing" if data[-1] > avg else "decreasing"
        confidence = random.uniform(0.7, 0.95)
        
        return f"Trend: {trend}, Confidence: {confidence:.2%}"
    
    def analyze_sentiment(self, text: str) -> str:
        \"\"\"Simple sentiment analysis\"\"\"
        positive_words = ["good", "great", "excellent", "amazing", "wonderful"]
        negative_words = ["bad", "terrible", "awful", "horrible", "disappointing"]
        
        text_lower = text.lower()
        positive_count = sum(1 for word in positive_words if word in text_lower)
        negative_count = sum(1 for word in negative_words if word in text_lower)
        
        if positive_count > negative_count:
            return "Positive 😊"
        elif negative_count > positive_count:
            return "Negative 😞"
        else:
            return "Neutral 😐"

class DataProcessor:
    \"\"\"Advanced data processing utilities\"\"\"
    
    def generate_sample_data(self, size: int = 100) -> List[float]:
        \"\"\"Generate sample data for testing\"\"\"
        np.random.seed(42)  # For reproducible results
        return np.random.normal(50, 15, size).tolist()
    
    def analyze_data(self, data: List[float]) -> Dict[str, Any]:
        \"\"\"Comprehensive data analysis\"\"\"
        if not data:
            return {"error": "No data provided"}
        
        return {
            "count": len(data),
            "mean": np.mean(data),
            "median": np.median(data),
            "std": np.std(data),
            "min": np.min(data),
            "max": np.max(data),
            "range": np.max(data) - np.min(data)
        }
    
    def detect_outliers(self, data: List[float], threshold: float = 2.0) -> List[int]:
        \"\"\"Detect outliers using z-score method\"\"\"
        if len(data) < 2:
            return []
        
        mean = np.mean(data)
        std = np.std(data)
        
        outliers = []
        for i, value in enumerate(data):
            z_score = abs((value - mean) / std) if std > 0 else 0
            if z_score > threshold:
                outliers.append(i)
        
        return outliers

def create_ai_model():
    \"\"\"Factory function to create AI model\"\"\"
    return {
        "type": "neural_network",
        "layers": [128, 64, 32, 1],
        "activation": "relu",
        "optimizer": "adam",
        "created_by": "CodeTalkie Watch App"
    }

def format_results(results: Dict[str, Any]) -> str:
    \"\"\"Format analysis results for display\"\"\"
    formatted = "📈 Analysis Results:\\n"
    for key, value in results.items():
        if isinstance(value, float):
            formatted += f"   {key}: {value:.2f}\\n"
        else:
            formatted += f"   {key}: {value}\\n"
    return formatted
"""
    }
    
    private func generateRequirementsFile() -> String {
        return """
# Python AI Project Requirements
# Generated by CodeTalkie Watch App

# Core scientific computing
numpy>=1.21.0
pandas>=1.3.0

# Machine learning and AI
scikit-learn>=1.0.0
tensorflow>=2.8.0
torch>=1.11.0

# Data visualization
matplotlib>=3.5.0
seaborn>=0.11.0
plotly>=5.0.0

# Natural language processing
nltk>=3.7
spacy>=3.4.0

# Web framework (optional)
flask>=2.0.0
fastapi>=0.75.0

# Utilities
requests>=2.27.0
python-dotenv>=0.19.0
tqdm>=4.62.0

# Development tools
jupyter>=1.0.0
ipython>=8.0.0

# Testing
pytest>=7.0.0
pytest-cov>=3.0.0
"""
    }
    
    private func generatePythonReadme(request: String) -> String {
        return """
# 🤖 Hello AI World - Python Project

> Generated by CodeTalkie Watch App from Apple Watch!

## 📋 Project Overview

This Python AI project was generated based on your voice request: **"\(request)"**

The project demonstrates advanced AI and machine learning concepts using Python, including:

- 🧠 **AI Assistant**: Intelligent helper with multiple capabilities
- 📊 **Data Processing**: Advanced data analysis and visualization
- 🔮 **Predictive Modeling**: AI-powered predictions and insights
- 🎯 **Pattern Recognition**: Automated pattern detection

## 🚀 Quick Start

### Prerequisites
- Python 3.8 or higher
- pip package manager

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd <repository-name>
   ```

2. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

3. **Run the application**
   ```bash
   python hello_ai.py
   ```

## 📁 Project Structure

```
📦 AI Project
├── 🐍 hello_ai.py          # Main application entry point
├── 🔧 ai_utils.py          # AI utilities and helper classes
├── 📋 requirements.txt     # Python dependencies
└── 📖 README.md           # This file
```

## 🧠 Features

### AIAssistant Class
- **Greeting System**: Friendly AI introduction
- **Prediction Engine**: Data-driven predictions
- **Sentiment Analysis**: Text emotion detection

### DataProcessor Class
- **Sample Data Generation**: Create test datasets
- **Statistical Analysis**: Comprehensive data insights
- **Outlier Detection**: Identify anomalous data points

## 📊 Example Usage

```python
from ai_utils import AIAssistant, DataProcessor

# Initialize AI components
assistant = AIAssistant()
processor = DataProcessor()

# Generate and analyze data
data = processor.generate_sample_data(100)
results = processor.analyze_data(data)

# Make AI predictions
prediction = assistant.make_prediction(data)
print(f"AI Prediction: {prediction}")
```

## 🔧 Advanced Features

- **Machine Learning Ready**: Structured for ML model integration
- **Extensible Architecture**: Easy to add new AI capabilities
- **Production Ready**: Includes error handling and logging
- **Well Documented**: Comprehensive code documentation

## 🎯 Next Steps

1. **Customize the AI logic** in `ai_utils.py`
2. **Add your own data sources** to `hello_ai.py`
3. **Implement machine learning models** using scikit-learn or TensorFlow
4. **Create visualizations** with matplotlib or plotly
5. **Deploy to cloud platforms** like AWS, GCP, or Azure

## 🤖 Generated by CodeTalkie

This project was created using voice commands on an Apple Watch! 

- **Generated on**: \(Date().formatted(date: .abbreviated, time: .shortened))
- **Voice Request**: "\(request)"
- **Technology**: Python + AI/ML
- **Platform**: Apple Watch → GitHub

## 📚 Learning Resources

- [Python Official Documentation](https://docs.python.org/)
- [NumPy User Guide](https://numpy.org/doc/stable/user/)
- [Pandas Documentation](https://pandas.pydata.org/docs/)
- [Scikit-learn Tutorials](https://scikit-learn.org/stable/tutorial/)
- [TensorFlow Guides](https://www.tensorflow.org/guide)

---

**Happy Coding! 🚀**

*Created with ❤️ by CodeTalkie Watch App*
"""
    }
}

struct FileChange {
    let path: String
    let content: String
    let operation: FileOperation
    let diff: String?
}

enum FileOperation {
    case create
    case update
    case delete
}

struct CodeGenerationResponse {
    let files: [FileChange]
    let commitMessage: String
    let summary: String
    let branchName: String?
}

// MARK: - WatchConnectivity Delegate for Watch
#if canImport(WatchConnectivity)
class WatchConnectivityDelegate: NSObject, ObservableObject, WCSessionDelegate {
    @Published var receivedToken: String?
    @Published var receivedUsername: String?
    
    override init() {
        super.init()
        if WCSession.isSupported() {
            WCSession.default.delegate = self
            WCSession.default.activate()
            print("Watch: WatchConnectivity session activation started")
        }
    }
    
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        print("Watch: WatchConnectivity session activated with state: \(activationState.rawValue)")
        if let error = error {
            print("Watch: WatchConnectivity activation error: \(error)")
        }
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        print("Watch: Received message from iPhone: \(message)")
        
        DispatchQueue.main.async {
            if let action = message["action"] as? String {
                switch action {
                case "tokenUpdate":
                    if let token = message["token"] as? String,
                       let username = message["username"] as? String {
                        print("Watch: Received token update from iPhone")
                        print("Watch: Token prefix: \(String(token.prefix(10)))...")
                        print("Watch: Username: \(username)")
                        
                        self.receivedToken = token
                        self.receivedUsername = username
                        
                        // Store locally on Watch
                        UserDefaults.standard.set(token, forKey: "github_token_watch")
                        UserDefaults.standard.set(username, forKey: "github_username_watch")
                        UserDefaults.standard.set(token, forKey: "github_token_shared")
                        UserDefaults.standard.set(username, forKey: "github_username_shared")
                        UserDefaults.standard.synchronize()
                        
                        replyHandler(["status": "success", "message": "Token received and stored"])
                    } else {
                        replyHandler(["status": "error", "message": "Invalid token data"])
                    }
                    
                case "tokenClear":
                    print("Watch: Received token clear request from iPhone")
                    self.receivedToken = nil
                    self.receivedUsername = nil
                    
                    // Clear local storage
                    UserDefaults.standard.removeObject(forKey: "github_token_watch")
                    UserDefaults.standard.removeObject(forKey: "github_username_watch")
                    UserDefaults.standard.removeObject(forKey: "github_token_shared")
                    UserDefaults.standard.removeObject(forKey: "github_username_shared")
                    UserDefaults.standard.synchronize()
                    
                    replyHandler(["status": "success", "message": "Token cleared"])
                    
                default:
                    replyHandler(["status": "error", "message": "Unknown action"])
                }
            } else {
                replyHandler(["status": "error", "message": "No action specified"])
            }
        }
    }
    
    func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
        print("Watch: Received application context from iPhone: \(applicationContext)")
        
        DispatchQueue.main.async {
            if let cleared = applicationContext["cleared"] as? Bool, cleared {
                print("Watch: Token cleared via application context")
                self.receivedToken = nil
                self.receivedUsername = nil
                
                // Clear local storage
                UserDefaults.standard.removeObject(forKey: "github_token_watch")
                UserDefaults.standard.removeObject(forKey: "github_username_watch")
                UserDefaults.standard.removeObject(forKey: "github_token_shared")
                UserDefaults.standard.removeObject(forKey: "github_username_shared")
                UserDefaults.standard.synchronize()
            } else if let token = applicationContext["token"] as? String,
                      let username = applicationContext["username"] as? String,
                      !token.isEmpty {
                print("Watch: Received token via application context")
                print("Watch: Token prefix: \(String(token.prefix(10)))...")
                print("Watch: Username: \(username)")
                
                self.receivedToken = token
                self.receivedUsername = username
                
                // Store locally
                UserDefaults.standard.set(token, forKey: "github_token_watch")
                UserDefaults.standard.set(username, forKey: "github_username_watch")
                UserDefaults.standard.set(token, forKey: "github_token_shared")
                UserDefaults.standard.set(username, forKey: "github_username_shared")
                UserDefaults.standard.synchronize()
            }
        }
    }
}
#else
class WatchConnectivityDelegate: NSObject, ObservableObject {
    @Published var receivedToken: String?
    @Published var receivedUsername: String?
}
#endif

struct ContentView: View {
    @StateObject private var watchConnectivityDelegate = WatchConnectivityDelegate()
    @State private var isAuthenticated = false
    @State private var selectedRepository: String?
    @State private var repositories: [String] = []
    @State private var currentView: AppView = .dashboard
    @State private var navigationStack: [AppView] = []
    @State private var isProcessing = false
    @State private var isLoadingRepos = false
    @State private var errorMessage: String?
    @State private var githubToken: String?
    @State private var githubUsername: String?
    @State private var helloAIButtonState: HelloAIButtonState = .create
    @State private var createdBranch: String?
    @State private var generateCodeButtonState: GenerateCodeButtonState = .generate
    @State private var generatedFiles: [String] = []
    @State private var createHelloAIByLLMButtonState: CreateHelloAIByLLMButtonState = .create
    @State private var textGenerateCodeButtonState: TextGenerateCodeButtonState = .generate
    @State private var voiceInputMode: VoiceInputMode = .regularVoice
    @State private var voiceTranscription: String = ""
    @State private var textInput: String = ""
    @FocusState private var isTextFieldFocused: Bool
    
    enum HelloAIButtonState {
        case create
        case creating
        case commitAndPush
        case pushing
        case success
        case error
    }
    
    enum GenerateCodeButtonState {
        case generate
        case generating
        case creating
        case success
        case error
    }
    
    enum CreateHelloAIByLLMButtonState {
        case create
        case generating
        case creating
        case success
        case error
    }
    
    enum TextGenerateCodeButtonState {
        case generate
        case generating
        case creating
        case success
        case error
    }
    
    enum VoiceInputMode {
        case regularVoice
        case codeGeneration
    }
    
    enum AppView {
        case dashboard
        case authentication
        case repositorySelection
        case voiceInput
        case textInput
        case processing
    }
    
    // MARK: - Navigation Helper Functions
    private func navigateTo(_ view: AppView) {
        navigationStack.append(currentView)
        currentView = view
    }
    
    private func navigateBack() {
        if let previousView = navigationStack.popLast() {
            currentView = previousView
        } else {
            currentView = .dashboard // fallback to dashboard
        }
    }
    
    // MARK: - Back Button Component
    private var backButton: some View {
        HStack {
            Button(action: navigateBack) {
                HStack(spacing: 4) {
                    Image(systemName: "chevron.left")
                        .font(.caption)
                    Text("Back")
                        .font(.caption)
                }
                .foregroundColor(.blue)
                .padding(.vertical, 4)
                .padding(.horizontal, 8)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(8)
            }
            .buttonStyle(PlainButtonStyle())
            
            Spacer()
        }
        .padding(.bottom, 8)
    }
    
    var body: some View {
        Group {
            switch currentView {
            case .dashboard:
                dashboardView
            case .authentication:
                authenticationView
            case .repositorySelection:
                repositorySelectionView
            case .voiceInput:
                voiceInputView
            case .textInput:
                textInputView
            case .processing:
                processingView
            }
        }
        .onAppear {
            checkAuthentication()
            
            // Monitor for authentication changes from iPhone
            NotificationCenter.default.addObserver(
                forName: UserDefaults.didChangeNotification,
                object: nil,
                queue: .main
            ) { _ in
                checkAuthenticationStatus()
            }
        }
        .onDisappear {
            NotificationCenter.default.removeObserver(self, name: UserDefaults.didChangeNotification, object: nil)
        }
        .onReceive(watchConnectivityDelegate.$receivedToken) { token in
            if let token = token, !token.isEmpty {
                print("Watch: Received token via WatchConnectivity: \(String(token.prefix(10)))...")
                githubToken = token
                if !isAuthenticated {
                    isAuthenticated = true
                    currentView = .dashboard
                    selectedRepository = nil
                    repositories = []
                    print("Watch: ✅ Authenticated via WatchConnectivity!")
                }
            } else if token == nil && isAuthenticated {
                print("Watch: Token cleared via WatchConnectivity")
                githubToken = nil
                isAuthenticated = false
                currentView = .authentication
                selectedRepository = nil
                repositories = []
                errorMessage = nil
            }
        }
    }
    
    private func checkAuthentication() {
        let timestamp = Date().timeIntervalSince1970
        print("Watch: ===== AUTHENTICATION CHECK [\(timestamp)] =====")
        
        // Debug: Print current app state
        print("Watch: Current State - isAuthenticated: \(isAuthenticated), currentView: \(currentView)")
        
        // Debug: Inspect all UserDefaults keys
        debugUserDefaults()
        
        // Priority 1: Check iPhone-Watch shared token
        if let storedToken = UserDefaults.standard.string(forKey: "github_token_shared"),
           !storedToken.isEmpty {
            print("Watch: 🔍 Found token via shared UserDefaults")
            print("Watch: Token prefix: \(String(storedToken.prefix(10)))...")
            print("Watch: Token length: \(storedToken.count)")
            
            if validateTokenFormat(storedToken) {
                print("Watch: ✅ Token format is valid")
                githubToken = storedToken
                
                // Validate token with GitHub API
                validateTokenWithAPI(storedToken, source: "shared storage") { success in
                    if success {
                        DispatchQueue.main.async {
                            self.isAuthenticated = true
                            self.currentView = .dashboard
                            print("Watch: ✅ Authenticated via shared storage!")
                        }
                    } else {
                        print("Watch: ❌ Shared token validation failed")
                        self.checkNextTokenSource()
                    }
                }
                return
            } else {
                print("Watch: ❌ Invalid token format in shared storage")
            }
        } else {
            print("Watch: ❌ No token found in shared UserDefaults")
        }
        
        // Priority 2: Check Watch-specific token
        if let storedToken = UserDefaults.standard.string(forKey: "github_token_watch"),
           !storedToken.isEmpty {
            print("Watch: 🔍 Found token via watch UserDefaults")
            print("Watch: Token prefix: \(String(storedToken.prefix(10)))...")
            print("Watch: Token length: \(storedToken.count)")
            
            if validateTokenFormat(storedToken) {
                print("Watch: ✅ Token format is valid")
                githubToken = storedToken
                
                validateTokenWithAPI(storedToken, source: "watch storage") { success in
                    if success {
                        DispatchQueue.main.async {
                            self.isAuthenticated = true
                            self.currentView = .dashboard
                            print("Watch: ✅ Authenticated via watch storage!")
                        }
                    } else {
                        print("Watch: ❌ Watch token validation failed")
                        self.checkNextTokenSource()
                    }
                }
                return
            } else {
                print("Watch: ❌ Invalid token format in watch storage")
            }
        } else {
            print("Watch: ❌ No token found in watch UserDefaults")
        }
        
        // Priority 3: Check legacy token
        if let storedToken = UserDefaults.standard.string(forKey: "github_token"),
           !storedToken.isEmpty {
            print("Watch: 🔍 Found token via legacy UserDefaults")
            print("Watch: Token prefix: \(String(storedToken.prefix(10)))...")
            print("Watch: Token length: \(storedToken.count)")
            
            if validateTokenFormat(storedToken) {
                print("Watch: ✅ Token format is valid")
                githubToken = storedToken
                
                validateTokenWithAPI(storedToken, source: "legacy storage") { success in
                    if success {
                        DispatchQueue.main.async {
                            self.isAuthenticated = true
                            self.currentView = .dashboard
                            print("Watch: ✅ Authenticated via legacy storage!")
                        }
                    } else {
                        print("Watch: ❌ Legacy token validation failed")
                        self.checkCredentialsFile()
                    }
                }
                return
            } else {
                print("Watch: ❌ Invalid token format in legacy storage")
            }
        } else {
            print("Watch: ❌ No token found in legacy UserDefaults")
        }
        
        // Priority 4: Check credentials file
        checkCredentialsFile()
    }
    
    private func checkNextTokenSource() {
        // This is called when a token validation fails, continue to next source
        checkCredentialsFile()
    }
    
    private func checkCredentialsFile() {
        print("Watch: 🔍 Checking credentials file...")
        print("Watch: ❌ Credentials file not accessible from watch app")
        print("Watch: This is expected - credentials are typically only available on iPhone")
        
        // No valid tokens found anywhere
        showAuthenticationScreen()
    }
    
    private func showAuthenticationScreen() {
        print("Watch: ❌ No valid token found in any location")
        print("Watch: Available options:")
        print("Watch: 1. Use Demo Mode")
        print("Watch: 2. Authenticate on iPhone")
        print("Watch: 3. Add token to credentials file")
        currentView = .authentication
        print("Watch: Showing authentication screen")
    }
    
    private func validateTokenFormat(_ token: String) -> Bool {
        // Check if token has valid GitHub format
        let hasValidPrefix = token.hasPrefix("ghp_") || token.hasPrefix("github_pat_")
        let hasValidLength = token.count >= 20
        
        print("Watch: Token validation - hasValidPrefix: \(hasValidPrefix), hasValidLength: \(hasValidLength)")
        
        return hasValidPrefix && hasValidLength
    }
    
    private func validateTokenWithAPI(_ token: String, source: String, completion: @escaping (Bool) -> Void) {
        print("Watch: 🌐 Validating token from \(source) with GitHub API...")
        
        // Check network connectivity first
        guard checkNetworkConnectivity() else {
            print("Watch: ❌ No network connectivity - skipping API validation")
            completion(false)
            return
        }
        
        Task {
            do {
                let url = URL(string: "https://api.github.com/user")!
                var request = URLRequest(url: url)
                request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
                request.setValue("codietalkie-watch-debug", forHTTPHeaderField: "User-Agent")
                request.timeoutInterval = 10.0
                
                print("Watch: Making API request to validate token...")
                let (data, response) = try await URLSession.shared.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    print("Watch: ❌ Invalid HTTP response")
                    completion(false)
                    return
                }
                
                print("Watch: API Response Status: \(httpResponse.statusCode)")
                
                if httpResponse.statusCode == 200 {
                    if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let username = json["login"] as? String {
                        print("Watch: ✅ Token validated successfully for user: @\(username)")
                        
                        // Store the username for repository operations
                        DispatchQueue.main.async {
                            self.githubUsername = username
                            // Also store in UserDefaults for persistence
                            UserDefaults.standard.set(username, forKey: "github_username_shared")
                            UserDefaults.standard.set(username, forKey: "github_username_watch")
                            UserDefaults.standard.synchronize()
                        }
                        
                        completion(true)
                    } else {
                        print("Watch: ❌ Could not parse user info from API response")
                        completion(false)
                    }
                } else {
                    let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
                    print("Watch: ❌ API validation failed: \(httpResponse.statusCode)")
                    print("Watch: Response: \(responseBody)")
                    completion(false)
                }
            } catch {
                print("Watch: ❌ Network error during token validation: \(error)")
                completion(false)
            }
        }
    }
    
    private func checkNetworkConnectivity() -> Bool {
        // Simple network connectivity check
        // In a real app, you might use Network framework for more sophisticated checking
        return true // For now, assume network is available
    }
    
    private func debugUserDefaults() {
        print("Watch: 📊 UserDefaults Debug Information:")
        
        let keys = [
            "github_token_shared",
            "github_token_watch", 
            "github_token",
            "github_username_shared",
            "github_username_watch"
        ]
        
        for key in keys {
            if let value = UserDefaults.standard.string(forKey: key) {
                let preview = value.isEmpty ? "(empty)" : "\(String(value.prefix(10)))..."
                print("Watch: \(key): \(preview)")
            } else {
                print("Watch: \(key): (not set)")
            }
        }
        
        // Check if UserDefaults is working at all
        let testKey = "debug_test_key"
        let testValue = "test_\(Date().timeIntervalSince1970)"
        UserDefaults.standard.set(testValue, forKey: testKey)
        
        if let retrievedValue = UserDefaults.standard.string(forKey: testKey),
           retrievedValue == testValue {
            print("Watch: ✅ UserDefaults is working correctly")
            UserDefaults.standard.removeObject(forKey: testKey)
        } else {
            print("Watch: ❌ UserDefaults appears to be malfunctioning!")
        }
    }
    
    private var dashboardView: some View {
        VStack(spacing: 16) {
            // Header
            VStack(spacing: 8) {
                Image(systemName: "mic.circle.fill")
                    .font(.system(size: 40))
                    .foregroundColor(.blue)
                
                Text("GitHub Voice Assistant")
                    .font(.headline)
                    .multilineTextAlignment(.center)
            }
            
            // Repository status
            if let repository = selectedRepository {
                VStack(spacing: 4) {
                    HStack {
                        Image(systemName: "folder.fill")
                            .foregroundColor(.blue)
                        Text(repository)
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    
                    Button("Change Repository") {
                        loadRepositories()
                        currentView = .repositorySelection
                    }
                    .font(.caption2)
                    .foregroundColor(.blue)
                }
                .padding(8)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(8)
            } else {
                Button("Select Repository") {
                    loadRepositories()
                    currentView = .repositorySelection
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 8)
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(20)
                .buttonStyle(PlainButtonStyle())
            }
            
            Spacer()
            
            // Hello AI Button
            if selectedRepository != nil {
                Button(action: handleHelloAIButtonTap) {
                    HStack(spacing: 8) {
                        if helloAIButtonState == .creating || helloAIButtonState == .pushing {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: helloAIButtonIcon)
                        }
                        
                        Text(helloAIButtonText)
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(helloAIButtonColor)
                    .foregroundColor(.white)
                    .cornerRadius(20)
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(helloAIButtonState == .creating || helloAIButtonState == .pushing)
                
                // Generate Code Button (Voice-driven)
                Button(action: handleGenerateCodeButtonTap) {
                    HStack(spacing: 8) {
                        if generateCodeButtonState == .generating || generateCodeButtonState == .creating {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: generateCodeButtonIcon)
                        }
                        
                        Text(generateCodeButtonText)
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(generateCodeButtonColor)
                    .foregroundColor(.white)
                    .cornerRadius(20)
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(generateCodeButtonState == .generating || generateCodeButtonState == .creating)
                
                // Text Generate Code Button (NEW)
                Button(action: handleTextGenerateCodeButtonTap) {
                    HStack(spacing: 8) {
                        if textGenerateCodeButtonState == .generating || textGenerateCodeButtonState == .creating {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: textGenerateCodeButtonIcon)
                        }
                        
                        Text(textGenerateCodeButtonText)
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(textGenerateCodeButtonColor)
                    .foregroundColor(.white)
                    .cornerRadius(20)
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(textGenerateCodeButtonState == .generating || textGenerateCodeButtonState == .creating)
                
                // Create Hello AI by LLM Button (Demo)
                Button(action: handleCreateHelloAIByLLMButtonTap) {
                    HStack(spacing: 8) {
                        if createHelloAIByLLMButtonState == .generating || createHelloAIByLLMButtonState == .creating {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: createHelloAIByLLMButtonIcon)
                        }
                        
                        Text(createHelloAIByLLMButtonText)
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(createHelloAIByLLMButtonColor)
                    .foregroundColor(.white)
                    .cornerRadius(20)
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(createHelloAIByLLMButtonState == .generating || createHelloAIByLLMButtonState == .creating)
            }
            
            // Main voice button
            Button(action: {
                if selectedRepository != nil {
                    currentView = .voiceInput
                } else {
                    loadRepositories()
                    currentView = .repositorySelection
                }
            }) {
                VStack(spacing: 8) {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 30))
                    
                    Text(selectedRepository != nil ? "Start Voice Request" : "Select Repository First")
                        .font(.caption)
                        .fontWeight(.medium)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
                .background(selectedRepository != nil ? Color.green : Color.gray)
                .foregroundColor(.white)
                .cornerRadius(25)
            }
            .buttonStyle(PlainButtonStyle())
            .disabled(selectedRepository == nil)
            
            Spacer()
            
            // Status message
            if let errorMessage = errorMessage {
                Text(errorMessage)
                    .font(.caption2)
                    .foregroundColor(.red)
                    .multilineTextAlignment(.center)
            } else {
                Text("Tap the microphone to create code with your voice")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }
        }
        .padding()
    }
    
    private var authenticationView: some View {
        VStack(spacing: 20) {
            // Back button at top
            if !navigationStack.isEmpty {
                backButton
            }
            
            Image(systemName: "person.circle.fill")
                .font(.system(size: 50))
                .foregroundColor(.blue)
            
            Text("GitHub Authentication")
                .font(.headline)
                .multilineTextAlignment(.center)
            
            Text("Authenticate on your iPhone first, then return here")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            Button("Check Authentication") {
                checkAuthentication()
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(20)
            .buttonStyle(PlainButtonStyle())
            
            Button("Use Demo Mode") {
                isAuthenticated = true
                repositories = ["demo-repo-1", "demo-repo-2", "my-project"]
                currentView = .dashboard
            }
            .font(.caption)
            .foregroundColor(.blue)
        }
        .padding()
    }
    
    private var repositorySelectionView: some View {
        VStack(spacing: 16) {
            // Back button at top
            backButton
            
            HStack {
                Text("Select Repository")
                    .font(.headline)
                
                if isLoadingRepos {
                    ProgressView()
                        .scaleEffect(0.8)
                }
            }
            
            ScrollView {
                VStack(spacing: 8) {
                    if repositories.isEmpty && !isLoadingRepos {
                        Text("No repositories found")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .padding()
                    } else {
                        ForEach(repositories, id: \.self) { repo in
                            Button(repo) {
                                selectedRepository = repo
                                navigateBack()
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 8)
                            .background(Color.gray.opacity(0.2))
                            .cornerRadius(8)
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                }
            }
        }
        .padding()
    }
    
    private var voiceInputView: some View {
        VStack(spacing: 20) {
            // Back button at top
            if !navigationStack.isEmpty {
                backButton
            }
            
            // Title based on mode
            Text(voiceInputMode == .codeGeneration ? "Generate Code" : "Voice Input")
                .font(.headline)
            
            Image(systemName: "waveform.circle.fill")
                .font(.system(size: 60))
                .foregroundColor(.red)
            
            // Instructions based on mode
            if voiceInputMode == .codeGeneration {
                VStack(spacing: 8) {
                    Text("Say what you want to create:")
                        .font(.caption)
                        .fontWeight(.medium)
                        .multilineTextAlignment(.center)
                    
                    Text("\"Create a calculator app\"\n\"Build a todo list\"\n\"Make a weather dashboard\"")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
            } else {
                Text("Tap to start recording your coding request")
                    .font(.caption)
                    .multilineTextAlignment(.center)
            }
            
            Button("Start Recording") {
                if voiceInputMode == .codeGeneration {
                    // Simulate voice recognition for code generation
                    simulateVoiceCodeGeneration()
                } else {
                    // Regular voice processing
                    navigateTo(.processing)
                    
                    // Simulate processing
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                        navigateBack()
                        errorMessage = nil
                    }
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(Color.red)
            .foregroundColor(.white)
            .cornerRadius(20)
            .buttonStyle(PlainButtonStyle())
            
            Button("Cancel") {
                voiceInputMode = .regularVoice // Reset mode
                navigateBack()
            }
            .font(.caption)
            .foregroundColor(.blue)
        }
        .padding()
    }
    
    private func simulateVoiceCodeGeneration() {
        // Simulate voice recognition and code generation
        currentView = .processing
        
        // Simulate voice recognition (2 seconds)
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            // Simulate transcription result
            let sampleRequests = [
                "Create a calculator app",
                "Build a todo list with dark mode",
                "Make a weather dashboard",
                "Create a simple game",
                "Build a portfolio website"
            ]
            
            let transcribedRequest = sampleRequests.randomElement() ?? "Create a useful application"
            self.voiceTranscription = transcribedRequest
            
            print("Watch: 🎤 Simulated voice transcription: \(transcribedRequest)")
            
            // Now generate code with LLM using the transcribed request
            if let repository = self.selectedRepository,
               let token = self.githubToken {
                self.generateCodeFromVoice(transcription: transcribedRequest, repository: repository, token: token)
            } else {
                // Return to dashboard if missing requirements
                self.currentView = .dashboard
                self.voiceInputMode = .regularVoice
                self.errorMessage = "Missing repository or authentication"
            }
        }
    }
    
    private func generateCodeFromVoice(transcription: String, repository: String, token: String) {
        print("Watch: 🎤➡️🤖 Generating code from voice: \(transcription)")
        generateCodeButtonState = .generating
        
        Task {
            do {
                // Parse repository name to get owner and repo
                let repoComponents = repository.components(separatedBy: "/")
                let owner: String
                let repo: String
                
                if repoComponents.count == 2 {
                    owner = repoComponents[0]
                    repo = repoComponents[1]
                } else {
                    // Use the authenticated user as owner
                    if let authenticatedUsername = githubUsername {
                        owner = authenticatedUsername
                        repo = repository
                        print("Watch: Using authenticated username as owner: \(owner)")
                    } else {
                        // Try to get username from UserDefaults
                        if let storedUsername = UserDefaults.standard.string(forKey: "github_username_shared") ?? 
                                                UserDefaults.standard.string(forKey: "github_username_watch") {
                            owner = storedUsername
                            repo = repository
                            githubUsername = storedUsername
                            print("Watch: Using stored username as owner: \(owner)")
                        } else {
                            // Last resort: get username from GitHub API
                            print("Watch: No username found, fetching from GitHub API...")
                            let fetchedUsername = try await getCurrentUsername(token: token)
                            owner = fetchedUsername
                            repo = repository
                            githubUsername = fetchedUsername
                            print("Watch: Fetched username from API: \(owner)")
                        }
                    }
                }
                
                print("Watch: Generating code from voice request for \(owner)/\(repo)")
                
                // Step 1: Generate code using LLM with voice transcription
                let mockRepository = Repository(name: repository)
                let codeResponse = try await LLMService.shared.processVoiceRequest(transcription, repository: mockRepository)
                
                DispatchQueue.main.async {
                    self.generateCodeButtonState = .creating
                }
                
                // Step 2: Create branch
                let timestamp = Int(Date().timeIntervalSince1970)
                let branchName = "feature/voice-generated-\(timestamp)"
                try await createBranch(owner: owner, repo: repo, branchName: branchName, token: token)
                
                // Step 3: Create multiple files from LLM response
                for file in codeResponse.files {
                    try await createOrUpdateFile(
                        owner: owner,
                        repo: repo,
                        path: file.path,
                        content: file.content,
                        message: codeResponse.commitMessage,
                        branch: branchName,
                        token: token
                    )
                }
                
                DispatchQueue.main.async {
                    print("Watch: ✅ Successfully generated code from voice with \(codeResponse.files.count) files in branch: \(branchName)")
                    self.generatedFiles = codeResponse.files.map { $0.path }
                    self.generateCodeButtonState = .success
                    self.currentView = .dashboard
                    self.voiceInputMode = .regularVoice // Reset mode
                    
                    // Reset button after 4 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
                        self.generateCodeButtonState = .generate
                        self.generatedFiles = []
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ Failed to generate code from voice: \(error)")
                    self.errorMessage = "Failed to generate code from voice: \(error.localizedDescription)"
                    self.generateCodeButtonState = .error
                    self.currentView = .dashboard
                    self.voiceInputMode = .regularVoice // Reset mode
                    
                    // Reset to generate state after 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.generateCodeButtonState = .generate
                        self.errorMessage = nil
                    }
                }
            }
        }
    }
    
    private func generateCodeFromText() {
        guard let repository = selectedRepository,
              let token = githubToken,
              !textInput.isEmpty else {
            print("Watch: ❌ Missing repository, token, or text input")
            return
        }
        
        print("Watch: ⌨️➡️🤖 Generating code from text: \(textInput)")
        textGenerateCodeButtonState = .generating
        currentView = .processing
        
        Task {
            do {
                // Parse repository name to get owner and repo
                let repoComponents = repository.components(separatedBy: "/")
                let owner: String
                let repo: String
                
                if repoComponents.count == 2 {
                    owner = repoComponents[0]
                    repo = repoComponents[1]
                } else {
                    // Use the authenticated user as owner
                    if let authenticatedUsername = githubUsername {
                        owner = authenticatedUsername
                        repo = repository
                        print("Watch: Using authenticated username as owner: \(owner)")
                    } else {
                        // Try to get username from UserDefaults
                        if let storedUsername = UserDefaults.standard.string(forKey: "github_username_shared") ?? 
                                                UserDefaults.standard.string(forKey: "github_username_watch") {
                            owner = storedUsername
                            repo = repository
                            githubUsername = storedUsername
                            print("Watch: Using stored username as owner: \(owner)")
                        } else {
                            // Last resort: get username from GitHub API
                            print("Watch: No username found, fetching from GitHub API...")
                            let fetchedUsername = try await getCurrentUsername(token: token)
                            owner = fetchedUsername
                            repo = repository
                            githubUsername = fetchedUsername
                            print("Watch: Fetched username from API: \(owner)")
                        }
                    }
                }
                
                print("Watch: Generating code from text request for \(owner)/\(repo)")
                
                // Step 1: Generate code using LLM with text input
                let mockRepository = Repository(name: repository)
                let codeResponse = try await LLMService.shared.processVoiceRequest(textInput, repository: mockRepository)
                
                DispatchQueue.main.async {
                    self.textGenerateCodeButtonState = .creating
                }
                
                // Step 2: Create branch
                let timestamp = Int(Date().timeIntervalSince1970)
                let branchName = "feature/text-generated-\(timestamp)"
                try await createBranch(owner: owner, repo: repo, branchName: branchName, token: token)
                
                // Step 3: Create multiple files from LLM response
                for file in codeResponse.files {
                    try await createOrUpdateFile(
                        owner: owner,
                        repo: repo,
                        path: file.path,
                        content: file.content,
                        message: codeResponse.commitMessage,
                        branch: branchName,
                        token: token
                    )
                }
                
                DispatchQueue.main.async {
                    print("Watch: ✅ Successfully generated code from text with \(codeResponse.files.count) files in branch: \(branchName)")
                    self.generatedFiles = codeResponse.files.map { $0.path }
                    self.textGenerateCodeButtonState = .success
                    self.currentView = .dashboard
                    self.textInput = "" // Clear text input
                    
                    // Reset button after 4 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
                        self.textGenerateCodeButtonState = .generate
                        self.generatedFiles = []
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ Failed to generate code from text: \(error)")
                    self.errorMessage = "Failed to generate code from text: \(error.localizedDescription)"
                    self.textGenerateCodeButtonState = .error
                    self.currentView = .dashboard
                    self.textInput = "" // Clear text input
                    
                    // Reset to generate state after 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.textGenerateCodeButtonState = .generate
                        self.errorMessage = nil
                    }
                }
            }
        }
    }
    
    
    private var inputModeSelectionView: some View {
        VStack(spacing: 20) {
            // Back button at top
            if !navigationStack.isEmpty {
                backButton
            }
            
            Text("How would you like to create code?")
                .font(.headline)
                .multilineTextAlignment(.center)
            
            // Voice Option
            Button(action: {
                voiceInputMode = .codeGeneration
                navigateTo(.voiceInput)
            }) {
                VStack(spacing: 12) {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.blue)
                    
                    Text("🎤 Voice")
                        .font(.caption)
                        .fontWeight(.medium)
                    
                    Text("Speak your request")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(15)
            }
            .buttonStyle(PlainButtonStyle())
            
            // Text Option  
            Button(action: {
                // For now, just show voice input until text input is fully implemented
                voiceInputMode = .codeGeneration
                navigateTo(.voiceInput)
            }) {
                VStack(spacing: 12) {
                    Image(systemName: "keyboard")
                        .font(.system(size: 40))
                        .foregroundColor(.green)
                    
                    Text("⌨️ Type")
                        .font(.caption)
                        .fontWeight(.medium)
                    
                    Text("Type your request")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
                .background(Color.green.opacity(0.1))
                .cornerRadius(15)
            }
            .buttonStyle(PlainButtonStyle())
            
            Button("Cancel") {
                navigateBack()
            }
            .font(.caption)
            .foregroundColor(.blue)
        }
        .padding()
    }
    
    
    private var textInputView: some View {
        VStack(spacing: 20) {
            // Back button at top
            if !navigationStack.isEmpty {
                backButton
            }
            
            Text("Type Your Request")
                .font(.headline)
            
            // Enhanced TextField with much better visibility
            VStack(alignment: .leading, spacing: 4) {
                Text("What would you like to create?")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                
                TextField("Create a calculator app", text: $textInput)
                    .font(.system(.caption, design: .default))
                    .padding(12)
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(Color.primary.opacity(0.05))
                            .overlay(
                                RoundedRectangle(cornerRadius: 10)
                                    .stroke(textInput.isEmpty ? Color.gray.opacity(0.3) : Color.blue, lineWidth: 2)
                            )
                    )
                    .focused($isTextFieldFocused)
            }
            
            VStack(spacing: 8) {
                Text("Examples:")
                    .font(.caption)
                    .fontWeight(.medium)
                
                VStack(spacing: 4) {
                    Text("\"Build a todo list\"")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\"Make a weather app\"")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("\"Create a game\"")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            
            Button("Generate Code") {
                generateCodeFromText()
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(textInput.isEmpty ? Color.gray : Color.blue)
            .foregroundColor(.white)
            .cornerRadius(20)
            .buttonStyle(PlainButtonStyle())
            .disabled(textInput.isEmpty)
            
            Button("Cancel") {
                textInput = ""
                navigateBack()
            }
            .font(.caption)
            .foregroundColor(.blue)
        }
        .padding()
        .onAppear {
            // Auto-focus the text field when view appears
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                isTextFieldFocused = true
            }
        }
    }
    
    private var processingView: some View {
        VStack(spacing: 20) {
            // Back button at top
            if !navigationStack.isEmpty {
                backButton
            }
            
            ProgressView()
                .scaleEffect(1.5)
            
            Text("Processing your request...")
                .font(.headline)
                .multilineTextAlignment(.center)
            
            Text("Converting speech to code...")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .padding()
    }
    
    private func loadRepositories() {
        print("Watch: ===== REPOSITORY LOADING DEBUG =====")
        print("Watch: loadRepositories() called")
        print("Watch: githubToken exists: \(githubToken != nil)")
        print("Watch: githubToken isEmpty: \(githubToken?.isEmpty ?? true)")
        
        // Check all possible token locations
        let sharedToken = UserDefaults.standard.string(forKey: "github_token_shared")
        let watchToken = UserDefaults.standard.string(forKey: "github_token_watch")
        print("Watch: Shared token exists: \(sharedToken != nil), isEmpty: \(sharedToken?.isEmpty ?? true)")
        print("Watch: Watch token exists: \(watchToken != nil), isEmpty: \(watchToken?.isEmpty ?? true)")
        
        if let token = sharedToken ?? watchToken {
            print("Watch: Found token in UserDefaults: \(String(token.prefix(10)))...")
            githubToken = token // Update our local token
        }
        
        guard let token = githubToken, !token.isEmpty else {
            print("Watch: ❌ NO TOKEN FOUND - Using demo repositories")
            print("Watch: This means iPhone-Watch sync is not working!")
            repositories = ["my-awesome-app", "web-project", "demo-backend", "mobile-app"]
            return
        }
        
        print("Watch: ✅ Token found! Starting to fetch real repositories...")
        print("Watch: Token prefix: \(String(token.prefix(10)))...")
        isLoadingRepos = true
        errorMessage = nil
        
        Task {
            do {
                let fetchedRepos = try await fetchGitHubRepositories(token: token)
                DispatchQueue.main.async {
                    print("Watch: ✅ SUCCESS! Fetched \(fetchedRepos.count) repositories: \(fetchedRepos)")
                    self.repositories = fetchedRepos
                    self.isLoadingRepos = false
                    
                    if fetchedRepos.isEmpty {
                        self.errorMessage = "No repositories found in your GitHub account"
                        print("Watch: ⚠️ Empty repository list from GitHub API")
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ ERROR fetching repositories: \(error)")
                    self.errorMessage = "GitHub API Error: \(error.localizedDescription)"
                    self.repositories = ["my-awesome-app", "web-project", "demo-backend", "mobile-app"] // Fallback
                    self.isLoadingRepos = false
                }
            }
        }
    }
    
    private func fetchGitHubRepositories(token: String) async throws -> [String] {
        let url = URL(string: "https://api.github.com/user/repos?per_page=20&sort=updated")!
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        
        print("Watch: Making GitHub API request to: \(url)")
        print("Watch: Authorization header: Bearer \(String(token.prefix(10)))...")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("Watch: Invalid HTTP response")
            throw URLError(.badServerResponse)
        }
        
        print("Watch: GitHub API response status: \(httpResponse.statusCode)")
        
        if httpResponse.statusCode != 200 {
            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
            print("Watch: GitHub API error response: \(responseBody)")
            
            if httpResponse.statusCode == 401 {
                throw NSError(domain: "GitHubAPI", code: 401, userInfo: [NSLocalizedDescriptionKey: "Invalid GitHub token"])
            } else if httpResponse.statusCode == 403 {
                throw NSError(domain: "GitHubAPI", code: 403, userInfo: [NSLocalizedDescriptionKey: "GitHub API rate limit exceeded"])
            } else {
                throw NSError(domain: "GitHubAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "GitHub API error: \(httpResponse.statusCode)"])
            }
        }
        
        do {
            let json = try JSONSerialization.jsonObject(with: data) as? [[String: Any]] ?? []
            let repoNames = json.compactMap { $0["name"] as? String }
            print("Watch: Parsed \(repoNames.count) repository names from API response")
            return repoNames
        } catch {
            print("Watch: JSON parsing error: \(error)")
            throw error
        }
    }
    
    // MARK: - Hello AI Button Properties
    private var helloAIButtonText: String {
        switch helloAIButtonState {
        case .create:
            return "🤖 Hello AI"
        case .creating:
            return "Creating..."
        case .commitAndPush:
            return "Commit & Push"
        case .pushing:
            return "Pushing..."
        case .success:
            return "✅ Done!"
        case .error:
            return "❌ Retry"
        }
    }
    
    private var helloAIButtonIcon: String {
        switch helloAIButtonState {
        case .create:
            return "robot.fill"
        case .creating:
            return "gear"
        case .commitAndPush:
            return "arrow.up.circle.fill"
        case .pushing:
            return "arrow.up.circle"
        case .success:
            return "checkmark.circle.fill"
        case .error:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private var helloAIButtonColor: Color {
        switch helloAIButtonState {
        case .create:
            return .orange
        case .creating:
            return .gray
        case .commitAndPush:
            return .green
        case .pushing:
            return .gray
        case .success:
            return .green
        case .error:
            return .red
        }
    }
    
    // MARK: - Generate Code Button Properties
    private var generateCodeButtonText: String {
        switch generateCodeButtonState {
        case .generate:
            return "🎤 Generate Code"
        case .generating:
            return "Gen..."
        case .creating:
            return "Making..."
        case .success:
            return "✅ Done!"
        case .error:
            return "❌ Retry"
        }
    }
    
    private var generateCodeButtonIcon: String {
        switch generateCodeButtonState {
        case .generate:
            return "code"
        case .generating:
            return "gear"
        case .creating:
            return "doc.badge.plus"
        case .success:
            return "checkmark.circle.fill"
        case .error:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private var generateCodeButtonColor: Color {
        switch generateCodeButtonState {
        case .generate:
            return .purple
        case .generating:
            return .gray
        case .creating:
            return .blue
        case .success:
            return .green
        case .error:
            return .red
        }
    }
    
    // MARK: - Create Hello AI by LLM Button Properties
    private var createHelloAIByLLMButtonText: String {
        switch createHelloAIByLLMButtonState {
        case .create:
            return "🐍 Hello AI by LLM"
        case .generating:
            return "Gen..."
        case .creating:
            return "Making..."
        case .success:
            return "✅ Done!"
        case .error:
            return "❌ Retry"
        }
    }
    
    private var createHelloAIByLLMButtonIcon: String {
        switch createHelloAIByLLMButtonState {
        case .create:
            return "sparkles"
        case .generating:
            return "gear"
        case .creating:
            return "doc.badge.plus"
        case .success:
            return "checkmark.circle.fill"
        case .error:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private var createHelloAIByLLMButtonColor: Color {
        switch createHelloAIByLLMButtonState {
        case .create:
            return .green
        case .generating:
            return .gray
        case .creating:
            return .blue
        case .success:
            return .green
        case .error:
            return .red
        }
    }
    
    // MARK: - Text Generate Code Button Properties
    private var textGenerateCodeButtonText: String {
        switch textGenerateCodeButtonState {
        case .generate:
            return "⌨️ Generate Code"
        case .generating:
            return "Gen..."
        case .creating:
            return "Making..."
        case .success:
            return "✅ Done!"
        case .error:
            return "❌ Retry"
        }
    }
    
    private var textGenerateCodeButtonIcon: String {
        switch textGenerateCodeButtonState {
        case .generate:
            return "keyboard"
        case .generating:
            return "gear"
        case .creating:
            return "doc.badge.plus"
        case .success:
            return "checkmark.circle.fill"
        case .error:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private var textGenerateCodeButtonColor: Color {
        switch textGenerateCodeButtonState {
        case .generate:
            return .teal
        case .generating:
            return .gray
        case .creating:
            return .blue
        case .success:
            return .green
        case .error:
            return .red
        }
    }
    
    // MARK: - Generate Code Button Action
    private func handleGenerateCodeButtonTap() {
        guard selectedRepository != nil else {
            print("Watch: ❌ No repository selected for code generation")
            return
        }
        
        // Navigate directly to voice input for code generation
        voiceInputMode = .codeGeneration
        navigateTo(.voiceInput)
    }
    
    // MARK: - Text Generate Code Button Action
    private func handleTextGenerateCodeButtonTap() {
        guard selectedRepository != nil else {
            print("Watch: ❌ No repository selected for text code generation")
            return
        }
        
        // Navigate directly to text input for code generation
        navigateTo(.textInput)
    }
    
    // MARK: - Create Hello AI by LLM Button Action
    private func handleCreateHelloAIByLLMButtonTap() {
        guard let repository = selectedRepository,
              let token = githubToken,
              !token.isEmpty else {
            print("Watch: ❌ Missing repository or token for Hello AI by LLM creation")
            return
        }
        
        switch createHelloAIByLLMButtonState {
        case .create:
            createHelloAIByLLM(repository: repository, token: token)
        case .error:
            // Retry generation
            createHelloAIByLLM(repository: repository, token: token)
        default:
            break
        }
    }
    
    private func createHelloAIByLLM(repository: String, token: String) {
        print("Watch: ✨ Starting Hello AI by LLM generation for repository: \(repository)")
        createHelloAIByLLMButtonState = .generating
        errorMessage = nil
        
        Task {
            do {
                // Parse repository name to get owner and repo
                let repoComponents = repository.components(separatedBy: "/")
                let owner: String
                let repo: String
                
                if repoComponents.count == 2 {
                    owner = repoComponents[0]
                    repo = repoComponents[1]
                } else {
                    // Use the authenticated user as owner
                    if let authenticatedUsername = githubUsername {
                        owner = authenticatedUsername
                        repo = repository
                        print("Watch: Using authenticated username as owner: \(owner)")
                    } else {
                        // Try to get username from UserDefaults
                        if let storedUsername = UserDefaults.standard.string(forKey: "github_username_shared") ?? 
                                                UserDefaults.standard.string(forKey: "github_username_watch") {
                            owner = storedUsername
                            repo = repository
                            githubUsername = storedUsername
                            print("Watch: Using stored username as owner: \(owner)")
                        } else {
                            // Last resort: get username from GitHub API
                            print("Watch: No username found, fetching from GitHub API...")
                            let fetchedUsername = try await getCurrentUsername(token: token)
                            owner = fetchedUsername
                            repo = repository
                            githubUsername = fetchedUsername
                            print("Watch: Fetched username from API: \(owner)")
                        }
                    }
                }
                
                print("Watch: Generating Hello AI project with LLM for \(owner)/\(repo)")
                
                // Step 1: Generate sophisticated Hello AI project using LLM
                let mockRepository = Repository(name: repository)
                let codeResponse = try await LLMService.shared.processVoiceRequest("Create a spectacular Hello AI World application that showcases advanced AI development concepts", repository: mockRepository)
                
                DispatchQueue.main.async {
                    self.createHelloAIByLLMButtonState = .creating
                }
                
                // Step 2: Create branch
                let timestamp = Int(Date().timeIntervalSince1970)
                let branchName = "feature/llm-hello-ai-\(timestamp)"
                try await createBranch(owner: owner, repo: repo, branchName: branchName, token: token)
                
                // Step 3: Create multiple files from LLM response
                for file in codeResponse.files {
                    try await createOrUpdateFile(
                        owner: owner,
                        repo: repo,
                        path: file.path,
                        content: file.content,
                        message: codeResponse.commitMessage,
                        branch: branchName,
                        token: token
                    )
                }
                
                DispatchQueue.main.async {
                    print("Watch: ✅ Successfully generated Hello AI by LLM with \(codeResponse.files.count) files in branch: \(branchName)")
                    self.createHelloAIByLLMButtonState = .success
                    
                    // Reset button after 4 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
                        self.createHelloAIByLLMButtonState = .create
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ Failed to create Hello AI by LLM: \(error)")
                    self.errorMessage = "Failed to create Hello AI by LLM: \(error.localizedDescription)"
                    self.createHelloAIByLLMButtonState = .error
                    
                    // Reset to create state after 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.createHelloAIByLLMButtonState = .create
                        self.errorMessage = nil
                    }
                }
            }
        }
    }
    
    private func generateCodeWithLLM(repository: String, token: String) {
        print("Watch: 🤖 Starting LLM code generation for repository: \(repository)")
        generateCodeButtonState = .generating
        errorMessage = nil
        
        Task {
            do {
                // Parse repository name to get owner and repo
                let repoComponents = repository.components(separatedBy: "/")
                let owner: String
                let repo: String
                
                if repoComponents.count == 2 {
                    owner = repoComponents[0]
                    repo = repoComponents[1]
                } else {
                    // Use the authenticated user as owner
                    if let authenticatedUsername = githubUsername {
                        owner = authenticatedUsername
                        repo = repository
                        print("Watch: Using authenticated username as owner: \(owner)")
                    } else {
                        // Try to get username from UserDefaults
                        if let storedUsername = UserDefaults.standard.string(forKey: "github_username_shared") ?? 
                                                UserDefaults.standard.string(forKey: "github_username_watch") {
                            owner = storedUsername
                            repo = repository
                            githubUsername = storedUsername
                            print("Watch: Using stored username as owner: \(owner)")
                        } else {
                            // Last resort: get username from GitHub API
                            print("Watch: No username found, fetching from GitHub API...")
                            let fetchedUsername = try await getCurrentUsername(token: token)
                            owner = fetchedUsername
                            repo = repository
                            githubUsername = fetchedUsername
                            print("Watch: Fetched username from API: \(owner)")
                        }
                    }
                }
                
                print("Watch: Generating code with LLM for \(owner)/\(repo)")
                
                // Step 1: Generate code using LLM
                let mockRepository = Repository(name: repository)
                let codeResponse = try await LLMService.shared.processVoiceRequest("Create a useful coding project", repository: mockRepository)
                
                DispatchQueue.main.async {
                    self.generateCodeButtonState = .creating
                }
                
                // Step 2: Create branch
                let timestamp = Int(Date().timeIntervalSince1970)
                let branchName = "feature/llm-generated-\(timestamp)"
                try await createBranch(owner: owner, repo: repo, branchName: branchName, token: token)
                
                // Step 3: Create multiple files from LLM response
                for file in codeResponse.files {
                    try await createOrUpdateFile(
                        owner: owner,
                        repo: repo,
                        path: file.path,
                        content: file.content,
                        message: codeResponse.commitMessage,
                        branch: branchName,
                        token: token
                    )
                }
                
                DispatchQueue.main.async {
                    print("Watch: ✅ Successfully generated and created \(codeResponse.files.count) files in branch: \(branchName)")
                    self.generatedFiles = codeResponse.files.map { $0.path }
                    self.generateCodeButtonState = .success
                    
                    // Reset button after 4 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
                        self.generateCodeButtonState = .generate
                        self.generatedFiles = []
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ Failed to generate code: \(error)")
                    self.errorMessage = "Failed to generate code: \(error.localizedDescription)"
                    self.generateCodeButtonState = .error
                    
                    // Reset to generate state after 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.generateCodeButtonState = .generate
                        self.errorMessage = nil
                    }
                }
            }
        }
    }
    
    // MARK: - Hello AI Button Action
    private func handleHelloAIButtonTap() {
        guard let repository = selectedRepository,
              let token = githubToken,
              !token.isEmpty else {
            print("Watch: ❌ Missing repository or token for Hello AI creation")
            return
        }
        
        switch helloAIButtonState {
        case .create:
            createHelloAIFile(repository: repository, token: token)
        case .commitAndPush:
            // File already created, this would be for additional commits if needed
            // For now, just show success since the file is already committed
            helloAIButtonState = .success
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                helloAIButtonState = .create
                createdBranch = nil
            }
        case .error:
            // Retry creation
            createHelloAIFile(repository: repository, token: token)
        default:
            break
        }
    }
    
    private func createHelloAIFile(repository: String, token: String) {
        print("Watch: 🤖 Starting Hello AI file creation for repository: \(repository)")
        helloAIButtonState = .creating
        errorMessage = nil
        
        Task {
            do {
                // Parse repository name to get owner and repo
                let repoComponents = repository.components(separatedBy: "/")
                let owner: String
                let repo: String
                
                if repoComponents.count == 2 {
                    owner = repoComponents[0]
                    repo = repoComponents[1]
                } else {
                    // Use the authenticated user as owner
                    if let authenticatedUsername = githubUsername {
                        owner = authenticatedUsername
                        repo = repository
                        print("Watch: Using authenticated username as owner: \(owner)")
                    } else {
                        // Try to get username from UserDefaults
                        if let storedUsername = UserDefaults.standard.string(forKey: "github_username_shared") ?? 
                                                UserDefaults.standard.string(forKey: "github_username_watch") {
                            owner = storedUsername
                            repo = repository
                            githubUsername = storedUsername // Update our local copy
                            print("Watch: Using stored username as owner: \(owner)")
                        } else {
                            // Last resort: get username from GitHub API
                            print("Watch: No username found, fetching from GitHub API...")
                            let fetchedUsername = try await getCurrentUsername(token: token)
                            owner = fetchedUsername
                            repo = repository
                            githubUsername = fetchedUsername
                            print("Watch: Fetched username from API: \(owner)")
                        }
                    }
                }
                
                print("Watch: Creating Hello AI file in \(owner)/\(repo)")
                
                let branchName = try await createHelloAIFileDirectly(
                    owner: owner,
                    repo: repo,
                    token: token
                )
                
                DispatchQueue.main.async {
                    print("Watch: ✅ Successfully created Hello AI file in branch: \(branchName)")
                    self.createdBranch = branchName
                    self.helloAIButtonState = .success
                    
                    // Reset button after 3 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                        self.helloAIButtonState = .create
                        self.createdBranch = nil
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    print("Watch: ❌ Failed to create Hello AI file: \(error)")
                    self.errorMessage = "Failed to create Hello AI file: \(error.localizedDescription)"
                    self.helloAIButtonState = .error
                    
                    // Reset to create state after 5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.helloAIButtonState = .create
                        self.errorMessage = nil
                    }
                }
            }
        }
    }
    
    // MARK: - GitHub API Functions
    private func createHelloAIFileDirectly(owner: String, repo: String, token: String) async throws -> String {
        print("Watch: 🤖 Creating Hello AI file in \(owner)/\(repo)")
        
        // Generate unique branch name
        let timestamp = Int(Date().timeIntervalSince1970)
        let branchName = "feature/hello-ai-world-\(timestamp)"
        
        // Create branch
        try await createBranch(owner: owner, repo: repo, branchName: branchName, token: token)
        
        // Create the hello-ai.py file content
        let helloAIContent = """
#!/usr/bin/env python3
\"\"\"
Hello, AI World! - A simple greeting from the future
Created by CodeTalkie Watch App
\"\"\"

def main():
    print("Hello, AI world!")
    print("Welcome to the age of intelligent assistants!")
    print("This file was created from an Apple Watch! 🤖⌚️")

if __name__ == "__main__":
    main()
"""
        
        // Create the file in the new branch
        try await createOrUpdateFile(
            owner: owner,
            repo: repo,
            path: "hello-ai.py",
            content: helloAIContent,
            message: "Created Hello, AI world!",
            branch: branchName,
            token: token
        )
        
        print("Watch: ✅ Successfully created Hello AI file in branch: \(branchName)")
        return branchName
    }
    
    private func createBranch(owner: String, repo: String, branchName: String, token: String, fromBranch: String? = nil) async throws {
        // Auto-detect the default branch if not specified
        let defaultBranch: String
        if let fromBranch = fromBranch {
            defaultBranch = fromBranch
        } else {
            defaultBranch = try await getDefaultBranch(owner: owner, repo: repo, token: token)
        }
        
        print("Watch: 🌿 Creating branch: \(branchName) from \(defaultBranch) in \(owner)/\(repo)")
        
        // First, get the SHA of the source branch
        let sourceSHA = try await getBranchSHA(owner: owner, repo: repo, branch: defaultBranch, token: token)
        
        // Create the new branch
        let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/git/refs")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        request.timeoutInterval = 30.0
        
        let requestBody = [
            "ref": "refs/heads/\(branchName)",
            "sha": sourceSHA
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response"])
        }
        
        guard httpResponse.statusCode == 201 else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            if httpResponse.statusCode == 422 {
                // Branch might already exist, that's okay for our use case
                print("Watch: ⚠️ Branch \(branchName) might already exist")
                return
            }
            throw NSError(domain: "GitHubAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode): \(errorMessage)"])
        }
        
        print("Watch: ✅ Successfully created branch: \(branchName)")
    }
    
    private func getDefaultBranch(owner: String, repo: String, token: String) async throws -> String {
        print("Watch: 🔍 Auto-detecting default branch for \(owner)/\(repo)")
        
        let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)")!
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            print("Watch: ⚠️ Could not get repository info, trying common branch names")
            // Fallback to common branch names
            return try await tryCommonBranches(owner: owner, repo: repo, token: token)
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let defaultBranch = json["default_branch"] as? String else {
            print("Watch: ⚠️ Could not parse default branch, trying common branch names")
            return try await tryCommonBranches(owner: owner, repo: repo, token: token)
        }
        
        print("Watch: ✅ Found default branch: \(defaultBranch)")
        return defaultBranch
    }
    
    private func tryCommonBranches(owner: String, repo: String, token: String) async throws -> String {
        let commonBranches = ["main", "master", "develop", "dev"]
        
        for branch in commonBranches {
            do {
                print("Watch: 🔍 Trying branch: \(branch)")
                _ = try await getBranchSHA(owner: owner, repo: repo, branch: branch, token: token)
                print("Watch: ✅ Found working branch: \(branch)")
                return branch
            } catch {
                print("Watch: ❌ Branch \(branch) not found: \(error)")
                continue
            }
        }
        
        throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Could not find any common branch names (main, master, develop, dev)"])
    }
    
    private func getBranchSHA(owner: String, repo: String, branch: String, token: String) async throws -> String {
        let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/branches/\(branch)")!
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to get branch SHA for \(branch)"])
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let commit = json["commit"] as? [String: Any],
              let sha = commit["sha"] as? String else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Could not parse branch SHA"])
        }
        
        return sha
    }
    
    private func getCurrentUsername(token: String) async throws -> String {
        print("Watch: 🔍 Fetching current username from GitHub API...")
        
        let url = URL(string: "https://api.github.com/user")!
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to get current user info"])
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let username = json["login"] as? String else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Could not parse username from API response"])
        }
        
        print("Watch: ✅ Fetched username: \(username)")
        
        // Store it for future use
        UserDefaults.standard.set(username, forKey: "github_username_shared")
        UserDefaults.standard.set(username, forKey: "github_username_watch")
        UserDefaults.standard.synchronize()
        
        return username
    }
    
    private func getExistingFileSHA(
        owner: String,
        repo: String,
        path: String,
        branch: String,
        token: String
    ) async throws -> String? {
        print("Watch: 🔍 Checking if file exists: \(path) on branch: \(branch)")
        
        let encodedPath = path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? path
        let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents/\(encodedPath)?ref=\(branch)")!
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        request.timeoutInterval = 15.0
        
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Watch: ⚠️ Invalid response when checking file existence")
                return nil
            }
            
            if httpResponse.statusCode == 404 {
                print("Watch: 📄 File doesn't exist - will create new file")
                return nil
            }
            
            guard httpResponse.statusCode == 200 else {
                print("Watch: ⚠️ Unexpected status when checking file: \(httpResponse.statusCode)")
                return nil
            }
            
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let sha = json["sha"] as? String else {
                print("Watch: ⚠️ Could not parse SHA from file check response")
                return nil
            }
            
            print("Watch: 📄 File exists with SHA: \(String(sha.prefix(8)))...")
            return sha
            
        } catch {
            print("Watch: ⚠️ Error checking file existence: \(error) - assuming file doesn't exist")
            return nil
        }
    }
    
    private func createOrUpdateFile(
        owner: String,
        repo: String,
        path: String,
        content: String,
        message: String,
        branch: String,
        token: String
    ) async throws {
        print("Watch: 📝 Creating/updating file: \(path) in \(owner)/\(repo) on branch: \(branch)")
        
        // Step 1: Check if file already exists and get its SHA
        let existingFileSHA = try await getExistingFileSHA(
            owner: owner,
            repo: repo,
            path: path,
            branch: branch,
            token: token
        )
        
        if let sha = existingFileSHA {
            print("Watch: 🔄 File exists, updating with SHA: \(String(sha.prefix(8)))...")
        } else {
            print("Watch: ✨ Creating new file")
        }
        
        // Step 2: Prepare the API request
        let encodedPath = path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? path
        let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents/\(encodedPath)")!
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("codietalkie-watch-app", forHTTPHeaderField: "User-Agent")
        request.timeoutInterval = 30.0
        
        // Step 3: Prepare the request body
        let contentData = content.data(using: .utf8)!
        let base64Content = contentData.base64EncodedString()
        
        var requestBody: [String: Any] = [
            "message": message,
            "content": base64Content,
            "branch": branch
        ]
        
        // Step 4: Include SHA if file exists (required for updates)
        if let sha = existingFileSHA {
            requestBody["sha"] = sha
            print("Watch: 📋 Request includes SHA for file update")
        } else {
            print("Watch: 📋 Request for new file creation (no SHA needed)")
        }
        
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        
        // Step 5: Make the API request
        print("Watch: 🌐 Making GitHub API request...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NSError(domain: "GitHubAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response from GitHub API"])
        }
        
        print("Watch: 📡 GitHub API response status: \(httpResponse.statusCode)")
        
        guard [200, 201].contains(httpResponse.statusCode) else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            print("Watch: ❌ GitHub API Error Details:")
            print("Watch: Status: \(httpResponse.statusCode)")
            print("Watch: Response: \(errorMessage)")
            print("Watch: File: \(path)")
            print("Watch: Branch: \(branch)")
            print("Watch: Had SHA: \(existingFileSHA != nil)")
            
            throw NSError(domain: "GitHubAPI", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "HTTP \(httpResponse.statusCode): \(errorMessage)"])
        }
        
        print("Watch: ✅ Successfully created/updated file: \(path)")
        
        // Log success details
        if let responseJson = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let commit = responseJson["commit"] as? [String: Any],
           let commitSha = commit["sha"] as? String {
            print("Watch: 📝 Commit SHA: \(String(commitSha.prefix(8)))...")
        }
    }
    
    private func checkAuthenticationStatus() {
        // Check if authentication status has changed from iPhone
        if let storedToken = UserDefaults.standard.string(forKey: "github_token_shared"),
           !storedToken.isEmpty {
            if !isAuthenticated {
                githubToken = storedToken
                isAuthenticated = true
                currentView = .dashboard
                selectedRepository = nil // Reset repository selection
                repositories = [] // Clear cached repositories
                print("Watch: Authentication detected via iPhone sync")
            }
        } else if let fallbackToken = UserDefaults.standard.string(forKey: "github_token_watch"),
                  !fallbackToken.isEmpty {
            if !isAuthenticated {
                githubToken = fallbackToken
                isAuthenticated = true
                currentView = .dashboard
                selectedRepository = nil
                repositories = []
                print("Watch: Authentication detected via fallback sync")
            }
        } else {
            if isAuthenticated {
                githubToken = nil
                isAuthenticated = false
                currentView = .authentication
                selectedRepository = nil
                repositories = []
                errorMessage = nil
                print("Watch: Logout detected via iPhone sync")
            }
        }
    }
}

#Preview {
    ContentView()
}
